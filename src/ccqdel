# This file is part of CCQHub.

# CCQHub is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# CCQHub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License
# along with CCQHub.  If not, see <http://www.gnu.org/licenses/>.


import argparse
import sys
import json
import traceback
import urllib2
import getpass
import os
import base64
from datetime import datetime

ccqCertDefaultFileLocation = str(os.path.expanduser('~')) + str("/ccqHubCert.cert")
ccqConfigFileLocationDefault = str(os.path.expanduser('/etc/')) + str("/ccqHub.config")
ccqConfigFileLocation = str(os.path.expanduser('~')) + str("/ccqHub.config")
ccqLogFileLocation = str(os.path.expanduser('~')) + str("/ccqHub.log")


def ccqdel():
    #TODO Change the wording of this to make sure it is actually referring to ccqHub not ccq in the Cloud
    parser = argparse.ArgumentParser(description="A utility that allows you to delete/kill jobs that have been submitted using the ccqsub command.")
    parser.add_argument('-V', '--version', action='version', version='ccqdel (version 0.3)')
    parser.add_argument('-j', '-j', help="The job Id of the job you want to delete/kill.", required=True)
    parser.add_argument('-f', '--f', action='store_true', help="Force kill/purge the job from the Scheduler.")
    parser.add_argument('-cl', metavar='<days_for_login_cert_to_be_valid_for>', help="Specifies the number of days that the generated ccq login certificate is valid for. This certificate is used so that you do not have to enter your username/password combination each time you submit a job. The default is 1 day, and the value must be an integer greater than or equal to 0. Setting the certificate valid length to 0 will disable the generation of login certificates. If the certLength variable is set in the ccq.config file then the value in the ccq.config file will override the value entered via the commandline.", default="1")

    #For use with app and ssh keys
    parser.add_argument('-i', '-i', help="The path to the file containing the app/ssh key for use when validating the user on the requested resources.", default=None)
    args = parser.parse_args()

    jobId = args.j
    jobForceDelete = args.f
    certLength = args.cl
    appKeyLocation = args.i

    configFile = None

    try:
        logFile = open(ccqLogFileLocation, "a")
    except IOError as e:
        #Can't open our log file so just write out to null device
        logFile = open(os.devnull, "w")

    try:
        configFile = open(ccqConfigFileLocation, 'r')
    except IOError as e:
        #Can't find a ccqconfig file in our home directory so check the default location
        try:
            configFile = open(ccqConfigFileLocationDefault, 'r')
        except IOError as e:
            print "\nThe user specific ccq.config file was not found in " + str(ccqConfigFileLocation) + " and the default ccq.config file was not found in " + str(ccqConfigFileLocationDefault) + " please create the config file before submitting a job to ccq."
            logFile.write(traceback.format_exc(str(e)))
            print "\n"
            sys.exit(0)

    if configFile is not None:
        try:
            for line in configFile:
                line = line.replace(" ", "")
                splitLine = line.split('=')
                if splitLine[0] == "certLength":
                    parsedCommand = splitLine[1]
                    certLength = parsedCommand[:len(parsedCommand)-1]
                if splitLine[0] == "submitHost":
                    parsedCommand = splitLine[1]
                    submitHost = parsedCommand[:len(parsedCommand)-1]
        except Exception as e:
            print "There was an error parsing the ccq.config file, please verify the config file entries and try running your command again."
            sys.exit(0)
    else:
        sys.exit(0)

    try:
        tempcertLength = int(certLength)
        if tempcertLength < 0:
            print "Invalid certificate valid for length. The number of days valid must be a valid integer greater than or equal to 0.\n"
            sys.exit(0)
    except:
        print "Invalid certificate valid for length. The number of days valid must be a valid integer greater than or equal to 0.\n"
        sys.exit(0)

    valKey = "unpw"
    userName = ""
    password = ""
    attempts = 0
    validUser = False
    isCert = False
    dateExpires = ""
    encodedUserName = ""
    encodedPassword = ""

    if os.path.isfile(ccqCertDefaultFileLocation) and int(certLength) != 0:
        isCert = True
        values = extractFieldsFromCert()
        if values['status'] == "success":
            valuesExtracted = values['payload']
            encodedUserName = valuesExtracted['userName']
            encodedPassword = valuesExtracted['password']
            valKey = valuesExtracted['valKey']
            dateExpires = valuesExtracted['dateExpires']
        else:
            pass
            #logFile.write("Unable to read values from the ccq certificate file. Reverting to username/password for authentication.\n")

    #Check to see if the user has an API key, if so open the file and read in the key.
    appKey = ""
    try:
        appKeyFile = open(str(appKeyLocation), "r")
        for line in appKeyFile:
            appKey += line
    except KeyError:
       appKey = None

    if not validUser:
        while attempts < 5 and not validUser:
            if not isCert and appKey is None:
                userName = raw_input("Please enter your username: \n")
                password = getpass.getpass("Please enter your password: \n")
                encodedPassword = encodeString("ccqpwdfrval", str(password))
                encodedUserName = encodeString("ccqunfrval", str(userName))
                valKey = "unpw"

            url = "https://" + str(submitHost) + "/srv/ccqdel"
            final = {"jobId": str(jobId), "userName": str(encodedUserName), "instanceId": None, "jobNameInScheduler": None, "password": str(encodedPassword), "jobForceDelete": jobForceDelete, 'schedulerType': None, 'schedulerInstanceId': None, 'schedulerInstanceName': None, 'schedulerInstanceIp': None, "valKey": str(valKey), "dateExpires": str(dateExpires), "certLength": str(certLength), "ccAccessKey": str(appKey)}
            data = json.dumps(final)
            headers = {'Content-Type': "application/json"}
            req = urllib2.Request(url, data, headers)
            try:
                res = urllib2.urlopen(req).read().decode('utf-8')
                #print res
                res = json.loads(res)
                if res['status'] == "failure":
                    if not isCert:
                        print str(res['payload']['message']) + "\n\n"
                        attempts += 1
                    else:
                        isCert = False
                        appKey = None
                elif res['status'] == "error":
                    #If we encounter an error NOT an auth failure then we exit since logging in again probably won't fix it
                    print res['payload']['message'] + "\n\n"
                    sys.exit(0)
                else:
                    print res['payload']['message'] + "\n\n"
                    validUser = True
                    if valKey == "unpw" and res['payload']['cert'] is not None and str(res['payload']['cert']) != str("None"):
                        certResponse = json.loads(res['payload']['cert'].replace("'", '"'))
                        if "error" not in certResponse:
                            newCcqCertFile = open(ccqCertDefaultFileLocation, "w")
                            newCcqCertFile.write(json.dumps(certResponse))
                            newCcqCertFile.close()
                            print "Successfully generated a new ccq certificate file that will expire in " + str(certLength) + " day(s)."
                        else:
                            print str(certResponse['error'])

            except Exception as ex:
                print traceback.format_exc(ex)
                print "\n"
                sys.exit(0)

        if not validUser:
            print "Maximum number of login attempts reached, please try again later."
            sys.exit(0)
        else:
            sys.exit(0)

def encodeString(k, field):
    enchars = []
    for i in xrange(len(field)):
        k_c = k[i % len(k)]
        enc = chr(ord(field[i]) + ord(k_c) % 256)
        enchars.append(enc)
    ens = "".join(enchars)
    return base64.urlsafe_b64encode(ens)

def extractFieldsFromCert():
    try:
        certFile = open(ccqCertDefaultFileLocation, "r")
        certObj = json.load(certFile)
        return {"status": "success", "payload": certObj}
    except:
        return {"status": "error", "payload": "There was a problem parsing the ccq certificate."}

ccqdel()