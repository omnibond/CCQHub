#Copyright Omnibond Systems, LLC. All rights reserved.

# This file is part of CCQHub.

# CCQHub is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# CCQHub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License
# along with CCQHub.  If not, see <http://www.gnu.org/licenses/>.
import json
import os
import sys
import policies
import ccqHubMethods
import traceback


def checkAdminRights():
    import ctypes

    try:
        # Check admin rights on Unix
        isAdmin = os.getuid()
        if isAdmin == 0:
            return {"status": "success", "payload": True}
        else:
            return {"status": "failure", "payload": False}
    except AttributeError:
        # Check admin rights Windows
        isAdmin = ctypes.windll.shell32.IsUserAnAdmin()
        if isAdmin:
            return {"status": "success", "payload": True}
        else:
            return {"status": "failure", "payload": False}


def validateCcqHubAdminKey(ccqHubAdminKeyPath):
    key = ""
    try:
        keyFile = open(os.path.dirname(os.path.realpath(__file__)) + "/.." + str(ccqHubMethods.ccqHubAdminKeyFile), "r")
        key = keyFile.readline()
    except Exception as e:
        # Check if the user has the key that is authorized to perform the actions
        if ccqHubAdminKeyPath is None:
            ccqHubAdminKeyPath = raw_input("Please enter the path to the ccqHubAdmin.key file. This file was generated by the ccqHubInstaller application and by default it is located in the .keys directory where ccqHub is installed. Make sure you have read access to this file before continuing.\n")

        try:
            keyFile = open(str(ccqHubAdminKeyPath), "r")
            key = keyFile.readline()
        except Exception as e:
            print "got here"
            return {"status": "error", "payload": {"error": "Unable to read the key from the provided file. Please make sure you have the required permissions and try again.", "traceback": traceback.format_exc(e)}}

    return {"status": "success", "payload": key}


def validateCcqHubJobKey(ccqHubJobKeyPath):
    key = ""

    # Try the path provided by the user first.
    if ccqHubJobKeyPath is not None:
        try:
            keyFile = open(str(ccqHubJobKeyPath), "r")
            key = keyFile.readline()
            return {"status": "success", "payload": key}
        except Exception as e:
            pass

    try:
        # Check to see if they have permission to use the ccqHubInstaller generated job key file if so use it, if not check the key they provided and if they did not provide one, prompt them for one before continuing.
        keyFile = open(os.path.dirname(os.path.realpath(__file__)) + "/.." + str(ccqHubMethods.ccqHubAdminKeyFile), "r")
        key = keyFile.readline()
        return {"status": "success", "payload": key}
    except Exception as e:
        # If the user has not provided a key path, ask them for one now.
        # Check if the user has the key that is authorized to perform the actions
        if ccqHubJobKeyPath is None:
            ccqHubJobKeyPath = raw_input("Please enter the path to a ccqHub generated key file with job submission permissions. These files are generated by the ccqHub installation application and should have been given to you by the ccqHub administrator\n")

        try:
            keyFile = open(str(ccqHubJobKeyPath), "r")
            key = keyFile.readline()
            return {"status": "success", "payload": key}
        except Exception as e:
            print "got here"
            return {"status": "error", "payload": {"error": "Unable to read the key from the provided file. Please make sure you have the required permissions and try again.", "traceback": traceback.format_exc(e)}}


def evaluatePermssions(subject, actions):
    # Get the valid actions and requiredAttributes
    actionsAndRequiredAttributes = policies.getValidActionsAndRequiredAttributes()

    typeOfSubject = subject['subjectType']
    subjectRecType = subject['subjectRecType']
    shortKey = ""
    if typeOfSubject == "key":
        shortKey = str(subject['subject']).split(":")[0]
        typeOfSubject = "keyId"
    response = ccqHubMethods.queryObj(None, "RecType-" + str(subjectRecType) + "-" + str(typeOfSubject) + "-" + str(shortKey) + "-name-", "query", "json", "beginsWith")
    tempRequiredObject = {}
    tempObtainedObject = {}
    if response['status'] == "success":
        results = response['payload']
        for identity in results:
            # We have the identity object
            try:
                decKeyObj = ccqHubMethods.decryptString(identity['keyInfo'])
                if decKeyObj['status'] != "success":
                    return {"status": "error", "payload": decKeyObj['payload']}
                else:
                    if str(subject['subject']) not in decKeyObj['payload']:
                        return {"status": "success", "payload": "This identity is authorized to perform the requested action(s)."}
            except Exception as e:
                print "Unable to validate the provided key."
                print traceback.format_exc(e)

            for action in actions:
                if action in actionsAndRequiredAttributes:
                    for category in actionsAndRequiredAttributes[action]:
                        if category == "attributes":
                            for attribute in actionsAndRequiredAttributes[action]:
                                if attribute in identity:
                                    tempObtainedObject[attribute] = str(identity[attribute])

                                tempRequiredObject[attribute] = str(actionsAndRequiredAttributes[action][attribute])
                        if category == "groups":
                            #TODO implement a way to check if the identity belongs to the group or not
                            pass
                        else:
                            pass

        # If we find the permission we are looking for pop it off the required object and move on. Have to make temp object
        # because you can't modify a dict you are looping through.
        for foundAttribute in tempObtainedObject:
            if str(tempObtainedObject[foundAttribute]) == str(tempRequiredObject[foundAttribute]):
                tempRequiredObject.pop(foundAttribute)

        if len(tempRequiredObject) == 0:
            return {"status": "failure", "payload": "This identity is not authorized to perform the requested action(s)."}
        else:
            return {"status": "success", "payload": "This identity is authorized to perform the requested action(s)."}
    else:
        return {"status": "error", "payload": response['payload']}
