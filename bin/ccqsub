#!/usr/bin/python2.7
# This file is part of CCQHub.

# CCQHub is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2 of the License, or
# (at your option) any later version.

# CCQHub is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.

# You should have received a copy of the GNU Lesser General Public License
# along with CCQHub.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import base64
import os
import traceback
import urllib2
import sys
import json
import hashlib
import getpass
from datetime import date, datetime
import commands
import getpass

sys.path.append(os.path.dirname(os.path.realpath(__file__))+str("/../src"))
import ccqHubMethods
import credentials

ccqCertDefaultFileLocation = str(os.path.expanduser('~')) + str("/ccqHubCert.cert")
ccqConfigFileLocationDefault = str(os.path.expanduser('/etc/')) + str("/ccqHub.config")
ccqConfigFileLocation = str(os.path.expanduser('~')) + str("/ccqHub.config")
ccqLogFileLocation = str(os.path.expanduser('~')) + str("/ccqHub.log")

def ccqsub():
    #TODO Change the wording of this to make sure it is actually referring to ccqHub not ccq in the Cloud
    parser = argparse.ArgumentParser(description="A wrapper for common schedulers such as Torque, SGE, Condor, and SLURM. Gives the schedulers autoscaling capability within the Amazon Cloud. When a user submits a job using this script, the job script will be parsed, the number of instances needed determined, and the instances will be launched for the job at run-time. Commands that are specified in the job script take precedence over the options specified on the command line. These commands can be denoted inside of the jobscript itself by using the #CC directive. The commands that are available through the #CC directive are -it (instance type), -nt (network type), -ni (number of instances requested), -op (optimization type), -p (criteria priority), -cpu (number of CPUs requested), -mem (amount of memory in MB requested), -s (scheduler to use), -st (scheduler type), -jn (job name), -vt (volume type), -us (use spot), -sp (spot price). ccqsub will also try to create a generic submit script for the scheduler you are using if you do not specify a job script. The output files from the job will appear in the CloudyCluster user's home directory on the instance the job was submitted from by default if you are using a CloudyCluster instance to submit your files. However there may be a minute or two delay from when the job finishes to when the files appear on the machine the job was submitted from due to extra processing needed. If you submit from a host outside of CloudyCluster the output files will be stored in the CloudyCluster user's home directory on the Access Instance associated with the Cluster that the job was submitted to. This behavior can be changed by specifying the -o and -e PBS directives in your job scripts or using the -o and -e ccqsub command line arguments, these tell the scheduler to output the files to the directories specified inside of the job script instead of the defaults. If an output file is missing check the /opt/CloudyCluster/ccqsub/undeliveredJobOutput/<CloudyCluster_user_name> directory on the Scheduler the job was submitted on as this is the default directory for undeliverable job output files.")

    parser.add_argument('-V', action='version', version='ccqsub (version 0.1)')

    # For use with app and ssh keys
    parser.add_argument('-i', '-i', help="The path to the file containing the app/ssh key for use when validating the user on the requested resources.", default=None)

    # Remote system username, for use when utilizing an app key to authenticate
    parser.add_argument('-ru', metavar="<remote_username>", help="The username that you want the job to run as on the remote system.", default=None)

    # If there is a -js argument then the other arguments shouldn't be allowed to be specified due to possible conflicts
    # Job script file location
    parser.add_argument('-js', metavar='<job_script_location>', help="The path to the job script file that you want to submit to the scheduler.", default=None, required=True)
    # Job Name
    parser.add_argument('-jn', metavar='<job_name>', help="The name of the job that will be saved so you can resubmit the job later without having to resubmit the job script itself.", default=None)
    # Network Type Requested
    parser.add_argument('-nt', metavar='low|moderate|high|10GB', help="Specifies the amount of network capacity needed for the job. If not specified it defaults to \"default\" which means it will not factor into the calculation of instance type needed for the job.", default="default", choices=["low", "moderate", "high", "10GB"])
    # Number of total instances wanted
    parser.add_argument('-ni', metavar='<number_instances>', type=int, help="The number of instances that you want the job to run on. The default setting is 1 instance.", default=1)
    # Number of CPUs per instance
    parser.add_argument('-cpu', metavar='<cpu_count>', type=int, help="The number of CPUs that you want per instance that your job is running on. The default setting is 1 CPU per instance.", default=1)
    # Memory Per Instance
    parser.add_argument('-mem', metavar='<mem_size_in_MB>', type=int, help="The amount of memory (in MB) per instance. The default setting is 1000 MB (1GB) per instance.", default=1000)
    # Scheduler To use
    parser.add_argument('-s', metavar='<name_of_target/scheduler_to_use>', help="Specifies the name of the Scheduler/Target that you want to use. The default value is to use the default Scheduler/Target for the Scheduler type you have requested. The default Scheduler/Target can be changed utilizing the ccqHubModifyDefaultTargets utility.", default="default")
    # Scheduler Type
    parser.add_argument('-st', metavar='Torque|SLURM|ccq|default', help="Specifies the type of Scheduler that you want to use. The accepted values are Torque, Condor, SGE, and SLURM. If the Scheduler type is not specified with a job script then ccqsub will attempt to figure out from the job script what type of Scheduler the job is to be run on. If no job script is submitted then the value will default to the default Scheduler for the Cluster", default="default", choices=["Torque", "ccq", "SLURM", "default"])
    # Use Spot Instances
    parser.add_argument('-us', metavar='yes|no', help="Use spot instances instead of dedicated instances. The default option is \"no\"", default="no", choices=["yes", "no"])
    # Spot Instance Price
    parser.add_argument('-sp', metavar='<target_spot_price>', help="The targeted spot instance price that you will be willing to pay to run the instances. A valid spot price is a number formatted as 1.23 that contains no letters, and must be greater than 0. This argument must be specified if using spot instances.", default=None)
    # Instance type
    parser.add_argument('-it', metavar='<instance_type>', help="Specifies the Amazon EC2 instance type that the job is to be run on. If no instance type is specified, then the amount of RAM and CPUs will be used to determine an appropriate Amazon EC2 Instance. A default instance type can be set using the \"defaultInstanceType\" directive in the ccq Config file.", default="default")
    # Instance Type Optimization
    parser.add_argument('-op', metavar='cost|performance', help="Specifies whether to use the instance type that is most cost effective or one that will give better performance regardless of cost. The default is \"cost\".", default="cost", choices=["cost", "performance"])
    # Criteria Priority
    parser.add_argument('-p', metavar='mcn|mnc|cmn|cnm|ncm|nmc', help="Specifies the priority that is considered when calculating the appropriate instance type for the job. Where m = memory, n = network, and c = cpu. For example specifying \"-p ncm\" would mean that when calculating the instance type the priority is Network requirements, Cpu requirements, then Memory requirements. This means that Networking is considered first, then the number of Cps, then the amount of memory when choosing an instance type. The default is \"mcn\" or Memory, Cpus, and then Network.", default="mcn", choices=["mcn", "mnc", "cmn", "cnm", "ncm", "nmc"])
    # Volume Type of Instance
    parser.add_argument('-vt', metavar='magnetic|ssd', help="Specifies the type of Volume to launch the instances for the job on. The default is \"ssd\". This value can also be set using the volumeType=<volumeType> variable in the ccq.config file.", default="ssd", choices=["magnetic", "ssd"])
    # Certificate Valid Time
    parser.add_argument('-cl', metavar='<days_for_login_cert_to_be_valid_for>', help="Specifies the number of days that the generated ccq login certificate is valid for. This certificate is used so that you do not have to enter your username/password combination each time you submit a job. The default is 1 day, and the value must be an integer greater than or equal to 0. Setting the certificate valid length to 0 will disable the generation of login certificates. If the certLength variable is set in the ccq.config file then the value in the ccq.config file will override the value entered via the commandline.", default="1")
    # Check Pricing
    parser.add_argument('-pr', action='store_true', help="Specifies that ccq should print the estimated price for a specific job script but not run the job. No resources will be launched and the estimated price of the job will be shown. This only includes in the instance costs per hour.")
    # Location of file to write stdout to
    parser.add_argument('-o', metavar='<stdout_file_location>', help="The path to the file where you want the Standard Output from your job to be written too. The default location is the directory where ccqsub was invoked with the name of the file the job name combined with the job id on the machine where the job was submitted.", default="default")
    # Location of file to write stderr to
    parser.add_argument('-e', metavar='<stderr_file_location>', help="The path to the file where you want the Standard Error from your job to be written too. The default location is the directory where ccqsub was invoked with the name of the file the job name combined with the job id on the machine where the job was submitted.", default="default")

    args = parser.parse_args()

    appKeyLocation = args.i

    jobScriptLocation = args.js
    jobName = args.jn
    networkTypeRequested = args.nt
    numberOfInstancesRequested = args.ni
    numCpusRequested = args.cpu
    memoryRequested = args.mem
    schedulerToUse = args.s
    schedType = args.st
    useSpot = args.us
    spotPrice = args.sp
    requestedInstanceType = args.it
    optimizationChoice = args.op
    criteriaPriority = args.p
    volumeType = args.vt
    certLength = args.cl
    justPrice = args.pr
    remoteUserName = args.ru

    stdoutFileLocation = args.o
    stderrFileLocation = args.e

    controlNodeIpAddress = ""

    currentDirectoryToStoreOutput = os.getcwd()

    values = ccqHubMethods.readSubmitHostOutOfConfigFile()
    if values['status'] != "success":
        print values['payload']
        sys.exit(0)
    else:
        submitHost = str(values['payload']['host']) + ":" + str(values['payload']['port'])

    if remoteUserName is None:
        # We can either prompt the user for the remote username or just use their current username, for now we will opt to just use their current username
        remoteUserName = getpass.getuser()
        #remoteUserName = ccqHubMethods.getInput("remote username", "username that you want the job to run as on the remote system. This user must exist on the remote system or the job will fail", None, None)

    if jobScriptLocation is not None:
        status, output = commands.getstatusoutput("pwd")
        #print "A job script location was specified, ccqsub will read the ccqsub/job arguments from the job script instead of from the commandline!\n"
        ccOptionsParsed = {"numberOfInstancesRequested": str(numberOfInstancesRequested),  "numCpusRequested": str(numCpusRequested), "wallTimeRequested": "None", "stdoutFileLocation": str(stdoutFileLocation), "stderrFileLocation": str(stderrFileLocation), "combineStderrAndStdout": "None", "copyEnvironment": "None", "eventNotification": "None", "mailingAddress": "None", "jobRerunable": "None", "memoryRequested": str(memoryRequested), "accountToCharge": "None", "jobBeginTime": "None", "jobArrays": "None", "useSpot": str(useSpot), "spotPrice": str(spotPrice), "requestedInstanceType": str(requestedInstanceType), "networkTypeRequested": str(networkTypeRequested), "optimizationChoice": str(optimizationChoice),  "pathToExecutable": "None", "criteriaPriority": str(criteriaPriority), "schedulerToUse": str(schedulerToUse), "schedType": str(schedType), "volumeType": str(volumeType), "certLength": str(certLength), "jobWorkDir": str(output), "justPrice": str(justPrice)}
        if jobName is None:
            #If a job name is not specified with the job script then we assume the name to be the name of the job script
            splitJobScriptLocation = jobScriptLocation.split('/')
            jobName = splitJobScriptLocation[len(splitJobScriptLocation)-1]

    else:
        print "In this version of ccqsub you must submit a job script using the -js argument in order to submit a job. Please create a job script and submit your job again.\n"
        sys.exit(0)

    jobScriptText = ""

    if jobScriptLocation is not None or jobScriptLocation != "None":
        #Start spinning things up here!
        pbsLineCount = 0
        slurmLineCount = 0
        sgeLineCount = 0
        try:
            jobScript = open(jobScriptLocation, 'r')
            ccParameters = {}
            jobScriptText = ""
            for line in jobScript:
                jobScriptText += line
                if line[:3] == "#CC":
                    #It is a comment and could possibly be a ccqsub command/parameter
                    #List of possible ccqsub directives that we recognize and support
                    possibleCommands = ["-it", "-nt", "-op", "-p", "-ni", "-mem", "-cpu", "-s", "-st", "-jn", "-vt", "-us", "-sp"]
                    argumentNames = {"-mem": "memoryRequested", "-it": "requestedInstanceType", "-nt": "networkTypeRequested", "-op": "optimizationChoice", "-p": "criteriaPriority", "-ni": "numberOfInstancesRequested", "-cpu": "numCpusRequested", "-s": "schedulerToUse", "-st": "schedType", "-jn": "jobName", "-vt": "volumeType", "-us": "useSpot", "-sp": "spotPrice"}
                    splitLine = line.split(' ')
                    for command in possibleCommands:
                        if splitLine[1] == command:
                            #Set the local variable that could have been passed in command line here
                            parsedCommand = splitLine[2]
                            ccOptionsParsed[argumentNames[command]] = parsedCommand[:len(parsedCommand)-1]

                #Reallllly need to add error checking here to make sure they don't put in invalid options!!

                elif line[:4] == "#PBS":
                    pbsLineCount += 1
                    #Torque does not have a way to set the current working directory so it is not an option and the job
                    #runs from the location that the user calls qsub from
                    possibleCommands = ["-o", "-e", "-l"]
                    argumentNames = {"-o": "stdoutFileLocation", "-e": "stderrFileLocation"}
                    splitLine = line.split(' ')
                    if len(splitLine) > 1:
                        for command in possibleCommands:
                            if splitLine[1] == "-l":
                                possibleArgs = {"mem": "memoryRequested", "nodes": "numberOfInstancesRequested", "ppn": "numCpusRequested", "select": "numberOfInstancesRequested"}
                                subCommands = splitLine[2].split(":")
                                for subCommand in subCommands:
                                    parsedCommand = subCommand.split("=")
                                    try:
                                        if parsedCommand[0] != "walltime":
                                            ccOptionsParsed[possibleArgs[parsedCommand[0]]] = parsedCommand[1].replace("\n", "")
                                    except (IndexError, KeyError) as e:
                                        #The argument passed to the -l command in PBS is not required by ccqsub
                                        pass

                            elif len(splitLine) > 1:
                                if splitLine[1] == command:
                                    #Set the local variable that could have been passed in command line here
                                    parsedCommand = splitLine[2]
                                    ccOptionsParsed[argumentNames[command]] = parsedCommand.replace("\n", "")
                elif line[:7] == "#SBATCH":
                    slurmLineCount += 1
                    possibleCommands = ["-o", "-e", "-D", "--ntasks-per-node", "--mem", "-N", "--nodes"]
                    argumentNames = {"-o": "stdoutFileLocation", "--output": "stdoutFileLocation", "-e": "stderrFileLocation", "--error": "stderrFileLocation", "-D": "jobWorkDir", "--ntasks-per-node": "numCpusRequested", "--mem": "memoryRequested", "-N": "numberOfInstancesRequested", "--nodes": "numberOfInstancesRequested", "--workdir": "--workdir"}
                    splitLine = line.split(' ')
                    for command in possibleCommands:
                        if len(splitLine) > 1:
                            if splitLine[1] == command:
                                #Set the local variable that could have been passed in command line here
                                parsedCommand = splitLine[2]
                                ccOptionsParsed[argumentNames[command]] = parsedCommand.replace("\n", "")
                elif line[:2] == "#$":
                    sgeLineCount += 1
            if ccOptionsParsed['schedType'] == "default" and ccOptionsParsed['schedulerToUse'] == "default":
                if pbsLineCount > slurmLineCount and pbsLineCount > sgeLineCount:
                    ccOptionsParsed['schedType'] = "Torque"
                    schedType = "Torque"
                elif slurmLineCount > pbsLineCount and slurmLineCount > sgeLineCount:
                    ccOptionsParsed['schedType'] = "SLURM"
                    schedType = "SLURM"
                # elif sgeLineCount > pbsLineCount and sgeLineCount > slurmLineCount:
                #     ccOptionsParsed['schedType'] = "SGE"
                #     schedType = "SGE"
                else:
                    print "\nCannot determine the type of scheduler/target to submit this job to. Please re-submit the job and specify the scheduler/target you want to submit to using the -s directive in your job script or via the command line. You may also specify the type of job (Torque, SGE, SLURM, Condor, PBSPro) using the -st directive in your job script or via command line arguments.\n"
                    sys.exit(0)

        except IOError as e:
            print "The job script file that was specified (" + str(jobScriptLocation) + ") does not exist. Please check the file path and try again.\n"
            sys.exit(0)

        #See if the user wanted a specific instance type. If they did then we only use that instance type, if not ccq can choose what to use
        if str(ccOptionsParsed['requestedInstanceType']) != "default":
            ccOptionsParsed['userSpecifiedInstanceType'] = "true"
        else:
            ccOptionsParsed['userSpecifiedInstanceType'] = "false"

        # See if the user specified a spot price and didn't specify the -us flag if they didn't specify the flag then set it for them
        if str(ccOptionsParsed["spotPrice"]).lower() != "none":
            ccOptionsParsed['useSpot'] = "yes"

        #Make sure all the spot options are valid
        validateSpotInstanceParameters(ccOptionsParsed)

        #Make sure all the instance parameters that we can check here are valid
        validateInstanceParameters(ccOptionsParsed)

    values = generateJobMD5Hash(jobScriptText)
    if values['status'] != 'success':
        print values['payload']
        print "\n"
        sys.exit(0)
    else:
        jobMD5Hash = values['payload']['md5']

    valKey = "unpw"
    #userName = ""
    password = ""
    attempts = 0
    validUser = False
    isCert = False
    dateExpires = ""
    encodedUserName = ""
    encodedPassword = ""

    # TODO need to check to see if the user has access to the auto-generated job submit key and if so use that one. If not need to get the path to the key.
    #Check to see if the user has an API key, if so open the file and read in the key.
    ccAccessKey = ""

    if appKeyLocation is None:
        values = credentials.validateCcqHubAdminKey(ccqHubMethods.ccqHubAdminJobSubmitKeyFile)
        if values['status'] != "success":
            print values['payload']['error']
            print values['payload']['traceback']
            sys.exit(0)
        else:
            ccAccessKey = values['payload']
    else:
        try:
            ccAccessKey = open(str(appKeyLocation), "r")
            for line in ccAccessKey:
                ccAccessKey += line
        except Exception as e:
           ccAccessKey = None

    if not validUser:
        while attempts < 5 and not validUser:
            if not isCert and ccAccessKey is None:
                print "This version of ccqHub only supports key based submissions. Please provide the ccqHub access key via the -i commandline option and try again."
                sys.exit(0)
                # userName = raw_input("Please enter your username: \n")
                # password = getpass.getpass("Please enter your password: \n")
                # encodedPassword = encodeString("ccqpwdfrval", str(password))
                # encodedUserName = encodeString("ccqunfrval", str(userName))
                # valKey = "unpw"

            url = "http://" + str(submitHost) + "/ccqHubSub"
            final = {"jobScriptLocation": str(jobScriptLocation), "jobScriptFile": str(jobScriptText), "jobName": str(jobName), "ccOptionsCommandLine": ccOptionsParsed, "jobMD5Hash": jobMD5Hash, "userName": str(encodedUserName), "password": str(encodedPassword), "valKey": str(valKey), "dateExpires": str(dateExpires), "certLength": str(certLength), "ccAccessKey": str(ccAccessKey), "targetName": str(schedulerToUse), "remoteUserName": str(remoteUserName)}
            data = json.dumps(final)
            headers = {'Content-Type': "application/json"}
            req = urllib2.Request(url, data, headers)
            try:
                res = urllib2.urlopen(req).read().decode('utf-8')
                #print res
                res = json.loads(res)
                if res['status'] == "failure":
                    if not isCert and ccAccessKey is None:
                        print str(res['payload']['message']) + "\n\n"
                        attempts += 1
                    elif ccAccessKey is not None:
                        print "The key is not valid, please check your key and try again."
                        sys.exit(0)
                    else:
                        isCert = False
                        ccAccessKey = None
                elif res['status'] == "error":
                    #If we encounter an error NOT an auth failure then we exit since logging in again probably won't fix it
                    print res['payload']['message'] + "\n\n"

                    #We still logged in successfully so generate a new cert
                    if valKey == "unpw" and res['payload']['cert'] is not None and str(res['payload']['cert']) != str("None"):
                        certResponse = json.loads(res['payload']['cert'].replace("'", '"'))
                        if "error" not in certResponse:
                            newCcqCertFile = open(ccqCertDefaultFileLocation, "w")
                            newCcqCertFile.write(json.dumps(certResponse))
                            newCcqCertFile.close()
                            print "Successfully generated a new ccq certificate file that will expire in " + str(certLength) + " day(s).\n"
                        else:
                            print str(certResponse['error'])
                    sys.exit(0)
                else:
                    print res['payload']['message'] + "\n\n"
                    validUser = True
                    if valKey == "unpw" and res['payload']['cert'] is not None and str(res['payload']['cert']) != str("None"):
                        certResponse = json.loads(res['payload']['cert'].replace("'", '"'))
                        if "error" not in certResponse:
                            newCcqCertFile = open(ccqCertDefaultFileLocation, "w")
                            newCcqCertFile.write(json.dumps(certResponse))
                            newCcqCertFile.close()
                            print "Successfully generated a new ccq certificate file that will expire in " + str(certLength) + " day(s)."
                        else:
                            print str(certResponse['error'])

            except Exception as ex:
                print traceback.format_exc(ex)
                print "\n"
                sys.exit(0)

        if not validUser:
            print "Maximum number of login attempts reached, please try again later."
            sys.exit(0)
        else:
            sys.exit(0)


def validateSpotInstanceParameters(ccOptionsParsed):
    #Validate Spot Instance Information
    if ccOptionsParsed["useSpot"] == "yes":
        if ccOptionsParsed["spotPrice"] is not None:
            try:
                tempFloat = float(ccOptionsParsed["spotPrice"])
                if tempFloat <= 0:
                    print "You must specify a spot price greater than 0.\n"
                    sys.exit(0)
                else:
                    ccOptionsParsed["spotPrice"] = "{:1.222f}".format(tempFloat)
            except:
                print "The spot price you have entered is not valid. A valid spot price is a number formatted as 1.23 that contains no letters, and must be greater than 0.\n"
                sys.exit(0)
        else:
            print "If you specify the use of spot instances you must specify a target spot price and an instance type.\n"
            sys.exit(0)

        if str(ccOptionsParsed["requestedInstanceType"]).lower() == "default":
            print "If you specify the use of spot instances you must specify a specific instance type.\n"
            sys.exit(0)

def validateInstanceParameters(ccOptionsParsed):
    try:
        tempCPUs = int(ccOptionsParsed["numCpusRequested"])
        if tempCPUs <= 0:
            print "Invalid number of CPUs specified. The number of CPUs must be a valid integer greater than 0.\n"
            sys.exit(0)
    except:
        print "Invalid number of CPUs specified. The number of CPUs must be a valid integer greater than 0.\n"
        sys.exit(0)
    try:
        tempMemory = int(ccOptionsParsed["memoryRequested"])
        if tempMemory <= 0:
            print "Invalid amount of Memory specified. The amount of Memory must be a valid integer greater than 0.\n"
            sys.exit(0)
    except:
        print "Invalid amount of Memory specified. The amount of Memory must be a valid integer greater than 0.\n"
        sys.exit(0)
    try:
        tempNumInstances = int(ccOptionsParsed["numberOfInstancesRequested"])
        if tempNumInstances <= 0:
            print "Invalid number of requested instances. The amount of Instances Requested must be a valid integer greater than 0.\n"
            sys.exit(0)
    except:
        print "Invalid number of requested instances. The amount of Instances Requested must be a valid integer greater than 0.\n"
        sys.exit(0)

    try:
        tempcertLength = int(ccOptionsParsed["certLength"])
        if tempcertLength < 0:
            print "Invalid certificate valid length. The number of days valid must be a valid integer greater than or equal to 0.\n"
            sys.exit(0)
    except:
        print "Invalid certificate valid length. The number of days valid must be a valid integer greater than or equal to 0.\n"
        sys.exit(0)

    if ccOptionsParsed["optimizationChoice"] != "cost" and ccOptionsParsed["optimizationChoice"] != "performance":
        print "Invalid optimization choice specified. The valid optimization choices are \"cost\" or \"performance\".\n"
        sys.exit(0)
    if ccOptionsParsed["criteriaPriority"] != "mcn" and ccOptionsParsed["criteriaPriority"] != "mnc" and ccOptionsParsed["criteriaPriority"] != "cmn" and ccOptionsParsed["criteriaPriority"] != "cnm" and ccOptionsParsed["criteriaPriority"] != "ncm" and ccOptionsParsed["criteriaPriority"] != "nmc":
        print "Invalid criteria priority specified. The valid criteria priority are: mcn, mnc, cmn, cnm, ncm, or nmc.\n"
        sys.exit(0)
    if ccOptionsParsed["networkTypeRequested"] != "low" and ccOptionsParsed["networkTypeRequested"] != "moderate" and ccOptionsParsed["networkTypeRequested"] != "high" and ccOptionsParsed["networkTypeRequested"] != "10 Gigabit" and ccOptionsParsed["networkTypeRequested"] != "default" and ccOptionsParsed["networkTypeRequested"] != "20 Gigabit" and ccOptionsParsed["networkTypeRequested"] != "up to 10 gigabit":
        print "Invalid network type specified. The valid network types are: low, moderate, high, 10 Gigabit, or 20 Gigabit.\n"
        sys.exit(0)

def generateJobMD5Hash(jobScriptText):
    try:
        #First strip out any whitespace characters that are in the job script
        jobScriptText = ''.join(jobScriptText.split())

        #Calculate the MD5 hash for the job script:
        newJobScriptMD5Hash = hashlib.md5(jobScriptText).hexdigest()
        return {"status": "success", "payload": {"md5": newJobScriptMD5Hash}}
    except Exception as e:
        return {"status": "error", "payload": "There was a problem while checking the job script. Please try again in a little bit."}

def encodeString(k, field):
    enchars = []
    for i in xrange(len(field)):
        k_c = k[i % len(k)]
        enc = chr(ord(field[i]) + ord(k_c) % 256)
        enchars.append(enc)
    ens = "".join(enchars)
    return base64.urlsafe_b64encode(ens)

def extractFieldsFromCert():
    try:
        certFile = open(ccqCertDefaultFileLocation, "r")
        certObj = json.load(certFile)
        return {"status": "success", "payload": certObj}

    except:
        return {"status": "error", "payload": "There was a problem parsing the ccq certificate."}

ccqsub()